
## 9.1. 메모리 설정

```
이 섹션에서는 Neo4j 인스턴스를 위한 메모리 설정 방법을 설명합니다.  
```

### 9.1.1. 개요 

그림 9-1 Neo4j 메모리 관리와 같이, Neo4j 서버 RAM에는 세 가지 영역이 있습니다:  

##### 그림 9.1. Neo4j 메모리 관리
![](./9_1.png)

#### OS 메모리
운영 체제(OS)를 실행하기 위해 일부 메모리를 예약합니다. 운영 체제(OS) 용으로 RAM 크기를 명시적으로 설정할 수 없으므로 페이지 캐시와 힙 공간을 설정한 후에 나머지 RAM을 OS에서 사용합니다. OS용으로 충분한 메모리를 남겨 두지 않으면, Neo4j 실행 시 디스크로 바뀌어서 성능이 저하됩니다.

Neo4j만 실행되는 서버라면 1GB는 적절합니다. 그러나 예외적으로 큰 RAM을 가진 서버와 같이 OS 용 용량이 1GB보다 훨씬 큰 경우도 있습니다.

#### 루씬 인덱스 캐시
Neo4j는 인덱싱 기능 중 일부에 [아파치 루씬(Apache Lucene)](https://lucene.apache.org/)을 사용합니다. 인덱스에 적절한 메모리를 할당하여, 인덱스 룩업 성능을 최적화합니다. OS 메모리와 같이, 루씬(Lucene) 인덱스 캐시는 명시적으로 설정할 수 없습니다. 대신 필요한 메모리를 예측하여, 페이지 캐시와 힙(Heap) 공간을 설정하기 전 필요한 메모리 양을 예약합니다.  
 
#### 페이지 캐시
페이지 캐시는 디스크에 저장되는 Neo4j 데이터의 캐시에 사용됩니다. 디스크의 모든 그래프 데이터, 또는 대부분 그래프 데이터가 메모리에 캐시되면, 값비싼 디스크 액세스를 하지 않아 최적의 성능을 얻을 수 있습니다.  

Neo4j가 페이지 캐시에 사용할 수 있는 메모리를 지정하는 설정 변수는 ```dbms.memory.pagecache.size``` 입니다:

#### 힙 크기
힙(Heap) 공간은 쿼리 실행, 트랜잭션 상태, 그래프 관리 등에 사용됩니다. 필요한 힙의 크기는 Neo4j를 어떻게 사용하는지에 따라 달라집니다. 예를 들어, 실행 시간이 긴 쿼리나 큰 데이터셋 간에 데카르트 곱을 수행하는 쿼리의 경우는 간단한 쿼리보다 큰 힙이 필요합니다.

일반적으로 동시 작업을 유지하기 위해 충분히 큰 힙을 구성하려고합니다. 성능 문제가 발생할 경우 힙 증가 여부를 결정하기 위해 쿼리를 조정하고 메모리 사용을 모니터링합니다. 

힙 메모리 크기는 ```dbms.memory.heap.initial_size```와 
```dbms.memory.heap.max_size``` 설정 값에 의해 결정됩니다. 전체 가비지 컬렉션에 의한 일시 정지를 피하려면 두 설정 값을 같게 하는 것이 좋습니다.

#### 9.1.2. 고려사항 

**항상 명시적 구성 사용**

시스템의 동작을 잘 제어하려면 neo4j.conf에서 페이지 캐시 및 힙 크기 매개 변수를 정의하는 것이 좋습니다. 매개 변수가 명시적으로 정의되지 않은 경우 일부 휴리스틱 값은 사용 가능한 시스템 리소스를 기반으로 시작시에 계산됩니다.

**초기 메모리 추천**

일정 메모리를 배포하는 방법 초기 권장 사항을 얻고 싶을 경우, ```neo4j-admin memrec``` 명령어를 사용하십시오. 특정 유스 케이스마다 값을 조정할 수도 있습니다.


**데이터베이스 메모리 설정 검사**

```neo4j-admin memrec --database``` 명령어는 현재 데이터베이스에서 데이터 배포 및 데이터베이스의 인덱스를 조사할 때 유용합니다. 

예제 9.1. 데이터베이스의 메모리 설정을 알기 위해서 ```neo4j-admin memrec```명령어를 사용합니다. 

데이터베이스 파일의 총 사이즈를 측정할 경우.
```
$neo4j-home> bin/neo4j-admin memrec --database=graph.db
...
...
...
# Lucene indexes: 6690m
# Data volume and native indexes: 17050m
```

루씬(Lucene) 인덱스가 대략 6.7 GB 용량을 차지하는 것과 데이터 용량 및 네이티브 인덱스 결합은 17 GB를 차지 합니다. 

이 정보를 사용하여 메모리 구성 온전성을 검사할 수 있습니다.

- 데이터 볼륨의 값과 기본 인덱스를 값을 비교하십시오.
	```dbms.memory.pagecache.size```

- 루씬(Lucene) 인덱스 값과 할당 후 남은 메모리 양 비교
	```dbms.memory.pagecache.size``` 및 ```dbms.memory.heap.initial_size```


가능한 많은 데이터와 인덱스를 캐싱하려고 하지만 일부 프로덕션 시스템에서는 메모리 액세스가 제한되어 있으므로 서로 다른 영역 간 협상해야 합니다. 그 후 일정량의 테스트와 튜닝을 통해 사용 가능한 최적 메모리 분할을 파악합니다.

**메모리 사용의 인덱스 제공 영향**

Neo4j 이전 버전을 업그레이드한 후, 새 인덱스 사용을 할 때 특정 인덱스를 다시 작성하는 것이 좋습니다. 자세한 정보는 [섹션 9.2, “인덱스 설정”](./index-configuration.md)에서 확인할 수 있습니다. 인덱스를 다시 작성하면 메모리 사용량 분포가 변경됩니다. 많은 익덱스가 있는 데이터베이스에서는 루씬(Lucene)을 위해 상당한 양의 메모리가 예약되었을 수도 있습니다. 작성한 후 일부 메모리를 페이지 캐시에 할당해야 할 수도 있습니다. ```neo4j-admin memrec --database```를 사용하여 색인을 재구성하기 전과 후에 데이터베이스를 검사하십시오.

### 9.1.3. 용량 계획

많은 사용 사례에서, 가능한 한 많은 데이터와 인덱스를 캐시하는 것이 중요합니다.아래 예는 이미 실행되고 있고 후에 배포 할 포러덕션 또는 계획 중인지에 따라 페이지 캐시를 예측하는 방법을 보여줍니다. 
 
예제 9.2. 기존 Neo4j 데이터베이스의 페이지 캐시 측정 

먼저 데이터 및 인덱스의 총 사이즈를 측정하고, 몇 가지 인자(예: 20%)를 곱셈합니다.  
```
$neo4j-home> bin/neo4j-admin memrec --database=graph.db
...
...
...
# Lucene indexes: 6690m
# Data volume and native indexes: 35050m
```

결합된 데이터 용량 및 네이티브 인덱스는 대력 35GB를 차지합니다. 구체적인 사례에서 우리는 20 %가 성장을 위한 충분한 헤드 룸을 제공할 것으로 예상합니다.

```dbms.memory.pagecache.size``` = 1.2 * (35GB) = 42GB

다음 neo4j.conf을 이용해서 페이지 캐시를 설정합니다. 

```
dbms.memory.pagecache.size=42GB
```

예제 9.3. 새로운 Neo4j 데이터베이스 페이지 캐시 예측

미래 데이터베이스를 계획할 때 데이터의 일부를 가져 오기를 실행 한 다음 결과 저장소 크기에 해당 분수를 더한 값과 증가 비율을 곱하면 유용합니다. 예를 들어, 1/100의 데이터를 임포트하고 용량 및 네이티브 인덱스를 측정합니다. 그 후, 그 숫자에 120을 곱하여 결과 ​크기를 정하고 20%의 여유를 둡니다. 

데이터의 1/100을 테스트 데이터베이스로 가져온 것으로 가정합니다.

```dbms.memory.pagecache.size``` = 120*(350 MB) =  30GB
다음과 같이 neo4j.conf에 페이지 캐시를 설정합니다:
```
dbms.memory.pagecache.size=30G
```