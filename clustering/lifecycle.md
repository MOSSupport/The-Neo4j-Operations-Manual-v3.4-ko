
### 4.2. 수명주기 

```
이 장에서는 Neo4j 인과관계 클러스터의 수명주기에 대해 다룹니다.
```

[4.1 "소개"](./introduction.md)에서는 Causal 클러스터의 개요를 제공했습니다. 이 장에서는 클러스터가 어떻게 작동하는지에 대해 더 깊이 이해할 것입니다. 클러스터 작동 방식에 대한 이해를 높임으로써 우리는 생산 시스템의 설계, 배포 및 문제 해결 대비를 더욱 강화할 것 입니다.

우리의 심층적인 학습은 클러스터의 수명 주기를 따를 것입니다. 클러스터가 형성되고 처리되면 코어 클러스터를 부팅하고 주요 아키텍처 기반을 확보할 것입니다. 그 후, 읽기 복제본을 추가하여 그들이 클러스터에 부트스트랩으로 결합하는 방법을 보여주고, 코어 서버 추적을 수행하여 이를 계속 유지합니다. 그러면 우리는 읽기 복제본 및 코어 서버를 종료 전 라이브 클러스터 환경에서 백업 방식을 볼 수 있습니다.

#### 4.2.2.1. 검색 프로토콜

검색 프로토콜은 인과관계 클러스터를 형성하는 첫 번째 단계입니다. 기존 코어 클러스터 서버에 대한 몇 가지 힌트를 얻고 이를 사용하여 네트워크 결합 프로토콜을 개시합니다. 

**그림 4.6. 인과관계 클러스터 discovery 프로토콜: Core-to-Core 또는 읽기 복제본-to-Core 전용**


![4.6.causal-clustering-discovery](./4.6.causal-clustering-discovery.svg)

이 힌트로부터 서버는 기존 클러스터에 참여하거나 자체 클러스터 중 하나를 형성할 것입니다.(분할된 브레인 클러스터 형성을 대해 걱정하지 마십시오. 코어 클러스터 형성은 Raft 프로토콜을 기반으로하기 에 안전합니다). 


>> discovery 프로토콜은 코어 서버인지 검색을 수행하는 읽기 복제본 인지에 관계없이 오직 코어 서버를 대상으로 합니다. 이는 읽기 복제본이 수없이 많으며 상대적으로 일시적이기 때문에 코어 서버는 시간이 지남에 따라 수가 적고 안정적이라고 예상하기 때문입니다.

힌트는  [neo4j.conf](/configuration/file-locations.md)에서 ```causal_clustering.initial_discovery_members```로서 전달되며, 일반적으로 점으로 구분 된 10 진수 IP 주소 및 보급 된 포트입니다. 검색 및 검색 구성 옵션에 대한 자세한 정보는 [초기 클러스터 멤버 발견](./setup-new-cluster.md) 섹션에서 확인할 수 있습니다. 힌트를 소비 할 때 서버는 나열된 다른 서버와 핸드 셰이크를 시도합니다. 다른 서버 또는 서버와의 성공적인 핸드 셰이크에서 현재 서버는 현재의 모든 토폴로지를 발견합니다.

검색 서비스는 인과관계 클러스터의 생애동안 실행되며 현재 이용가능한 서버 상태를 유지하고 고객이 고객 측 드라이버를 통해 적당한 서버에 쿼리를 라우팅할 때 사용합니다. 

### 4.2.2. 코어(Core) 회원 

검색을 수행하는 것은 코어 서버이며, 존재하는 코어 서버에 연결되면 Raft 프로토콜을 결합합니다. 

Raft는 Diego Ongaro가 2014 년 Ph.D에서 설계한 여러가지 비공유 서버에서 일관된 로그를 유지하기 위한 분산 알고리즘입니다. 자세한 내용은 [Raft 논문](https://ramcloud.stanford.edu/~ongaro/thesis.pdf)을 참조하십시오. 

Raft는 분산된 로그를 동기화 상태로 유지할 때 일반적인 역할을하여 클러스터 회원을 처리합니다. 클러스터에 결합하는 것은 클러스터 멤버쉽 항목을 Raft 로그에 넣은 후 기존 클러스터에서 안정적으로 복제하는 것을 포함합니다. 해당 항목이 알고리즘의 특정 인스턴스를 실행하는 Raft 컨센서스 그룹 구성원에게 적용되면 새 서버를 포함하도록 클러스터 보기를 업데이트합니다. 그러므로 회원은 Raft를 통해 거래된 데이터와 같이 안전한 속성에서 이익을 얻습니다.자세한 내용은 [섹션 4.2.4, Raft 프로토콜을 통한 거래](./lifecycle.md)를 참조하십시오. 

인스턴스가 다른 인스턴스에 커텍션을 하면, 인스턴스는 현재 클러스터를 결합할 수 있는 상태로 결정합니다. 자격을 갖추려면 Neo4j 인스턴스는 다른 멤버와 같이 동일한 데이터베이스 저장소를 클러스터의 호스트할 수 있거나(구형, 오래된 상태이더라도) 데이터베이스 저장소가 없이 새롭게 배포할 수 있어야 됩니다. 

### 4.2.3. 읽기 복사본 회원 

읽기 복사본이 검색을 수행할 때 공유 된 화이트보드에서 가능한 코어 클러스터의 연결되면 자신을 추가 합니다. 

**그림 4.4. 공유된 화이트 보드에서 등록된 모든 읽기 복사본**

![read replica discovery](https://neo4j.com/docs/operations-manual/3.4/images/read-replica-discovery.svg)


화이트보드는 모든 라이브 읽기 복제본을 제공하며 이는 엔드-유저 어플리케이션을 지원하는 데이터베이스 드라이버 요청 라우팅 및 클러스터 상태 모니터링에 모두 사용됩니다. 

읽기 복제본은 Raft 프로토콜에 포함되지 않으며 다른 클러스터 토플러지에 영향을 미칠 수도 없습니다. 그러므로 Raft 외부에 공유된 화이트 보드는 매우 많은 양의 읽기 복제본으로 확장됩니다. 


화이트보드는 정상적으로 나가기보다 갑자기 실패하더라도 읽기 복제본이 클러스터에 결합하고 해제될 때까지 최신 상태로 유지됩니다. 

### 4.2.4. Raft 프로토콜을 통한 트랜잭션 

부트스트랩(bootstrapped)되면, 코어 서버는 데이터베이스 트랜잭션을 진행하는데 시간을 소요합니다. 
업데이트는 코어서버 주위에 Raft 프로토콜을 통해서 확실하게 복제됩니다. 업데이트는 그래프 모델에 연속적으로 적용된 트랜잭션 명령어를 포함하는 Raft 로그 형식으로 나타납니다. 

Raft 디자인의 주된 목표는 쉽게 이해할 수 있게 하여 구현시 까다로운 버그가 숨어있는 곳이 적게하는 것 입니다. 데이터베이스 조작자가 인과관계 클러스터 내 그들의 코어 서버를 쉽게 추론하는 부작용이 나타날수도 있습니다. 

현재 용어(논리 시계)에 대한 Raft 리더는 트랜잭션(Raft 용어로 `엔트리`)을 로컬 로드 헤드에 추가하고 다른 인스턴스에서도 동일한 작업을 하도록 요청합니다. 리더가 앤트리에 추가된 많은 인스턴스를 확인한다면, 이것은 Raft에 추가된 것으로 간주합니다. 클라이언트 어플리케이션은 시스템의 모든 에러를 수용하기에 충분한 종복 시스템이 있으므로 트랜잭션이 안전하게 커밋된 것을 알림받습니다. 

Raft 프로토콜은 인스턴스가 수행하는 세 가지 역할을 설명합니다: 리더, 팔로워, 후보자. 역할은  일시적이며 모든 코어 서버는 클러스터 생애 동안 이 역할들을 수행할 수 있습니다. 컴퓨팅 과학의 관점에서 볼 때 그 상태를 이해하는 것은 흥미로운 일이지만 운영자는 지나치게 우려해서는 안됩니다 : 구현 세부사항 입니다. 
 
안전을 위해 Raft 프로토콜 인스턴스 내 특정 기간에 진행할 수 있는 리더는 단 한 명뿐입니다. 리더는 Raft 로그 항목에 명령을 내리고 팔로워와 관련하여 로그를 전달할 책임이 있습니다. 

팔로워는 그들의 로그를 현재 리더의 로그와 관련하여 유지합니다. 클러스터 내 참여자가 리더가 실패했다고 의심하면 후보자 상태로 리더를 다시 선출하도록 부추길 수 있습니다. Neo4j 코어 서버에서 이것은 500ms가 기본 단위인 ms 단위 시간에 발생합니다. 

최선의 상태에 있는 인스턴스가 (기존 리더를 포함하여) 리더로 선출될 수 있습니다. 리더의 "최고 상태"는 가장 높은 기간 및 긴 로그 그리고 가장 높게 기여한 앤터리로 결정됩니다. 


데이터 손실 없이 정애 조치 기능을 사용하면 장애 발생시에도 사용할 수 있습니다. Raft 인스턴스가 실패하더라도, 프로토콜은 데이터 손실 없이 실패한 인스턴스(또는 인스턴스)를 인수하기 위해 남아있는 인스턴스 중 가장 적합한 것과 결합할 수 있습니다. 이것은 Neo4j 인과관계 클러스터링이 애플리케이션에 계속 유효성을 제공하는 논-블로킹(non-blocking)의 핵심 일치 프로토콜 입니다.

### 4.2.5. 캐치 업(Catchup) 프로토콜 

읽기 복제본은 그래프 쿼리를 동시에 처리하고 코어 서버에서 그들의 로컬 그래프 저장소로 업데이트 하는데 많은 시간이 소요합니다. 

**그림 4.5. 코어에서 읽기 복제본으로 이동된 트랜잭션**

![read replica tx polling](https://neo4j.com/docs/operations-manual/3.4/images/read-replica-tx-polling.svg)

코어 서버에서 읽기 복제본으로 업데이트는 트랜잭션 이동에 의해 전파됩니다. 트랜잭션 이동은 읽기 복제본에서 주기적으로 수신하고 처리한 마지막 트랜잭션의 ID를 지정하여 코어 서버에서 폴링하면서 실행됩니다. 폴링 빈도는 운영상 선택 사항입니다. 

Neo4j 트랜잭션 ID는 변화가 없는 절대 정수 값(항상 증가하는)입니다. 이것은 트랜잭션이 코어 서버에서 마지막으로 처리된 트랜잭션 ID를 코어 서버의 트랜잭션 ID와 비교하여 
읽기 복사본이 적용 여부를 쉽게 판별하도록 합니다. 

읽기 복사본의 트랜잭션 히스토리와 코어 서버에 큰 차이가 있다면, 폴링은 이동되는 트랜잭션에 전송되지 않을 수도 있습니다. 이는 장기 실행 클러스터에 새 읽기 복제본이 도입되거나 상당한 기간 동안 읽기 복제본이 중단된 경우에 매우 유용합니다. 이런 경우 캐치업 프로토콜은 코어 서버와 읽기 복제본 사이 갭이 커서 트랜잭션 이동을 채울 수 없으며 직접 코어 서버에서 읽기 복제본으로 데이터베이스 저장소를 복사하도록 합니다. 라이브 시스템으로 작업하기 때문에, 데이터베이스 저장소의 끝에서 코어 서버의 데이터베이스가 변할 수도 있습니다. 읽기 복제본은 복사 작동 중 손실된 트랜잭션 사용이 가능하기 전에 요청하여 캐치 업을 완료합니다.


느린 데이터베이스 저장소 복사는 트랜잭션 코어 서버가 실질적으로 이동된 것과 같이 로그 이동을 통해 따라 잡기 위해서 읽기 복제본을 늦게 남겨둘 수도 있습니다. 이런 경우 읽기 복제본 서버는 캐치 업 프로토콜을 반복합니다. 걷잡을 수 없는 경우, 운영자는 빠른 백업에서 최근 저장한 파일의 스냅 샷, 복원 또는 파일 복사에 개입할 수 있습니다. 


### 4.2.6. 읽기 복제본 종료 

클린 종료 시 읽기 복제본은 클러스터의 공유된 화이트 보드를 개요에서 자신을 제거하기 위해 프로토콜 검색을 호출합니다. 또한, 데이터베이스가 추후에 즉시, 일관되게 사용하고 종료시켜 사용할 준비를 보장합니다. 

정전과 같이 완전히 종료되지 않은 경우, 코어 서버는 클러스터 개요를 유지하여 읽기 복제본 연결이 갑자기 끊어진 것을 알립니다. 이후 재부팅에서 읽기 복제본은 일관된 상태에 있도록 데이터베이스에 적용된 일부 트랜잭션을 롤백합니다. 

### 4.2.7. 코어 종료 

코어 서버 종료 시, 코어 서버 부팅과 같이 Raft 프로토콜에서 처리됩니다. 코어 서버가 종료되면, 이것은 코어 서버에 복제된 회원 앤트리를 Raft 로그에 첨부합니다. 대부분의 핵심 서버가 구성원 자격을 커밋하면, 리버 항목이 논리적으로 클러스터를 종료하여 안전하게 종료할 수 있습니다. 남아있는 인스턴스는 클러스터가 작아진 것을 수용하므로 내결함성이 떨어집니다. 만약 리버가 떠날 때 리더 역할을하면, 선출 이후 다른 코어 서버 역할을 수행할 것 입니다. 

종료 되지 않은 코어 서버가 남아 있는 것은 클러스터에 직접 알려주지 않아서 입니다. 대신 코어 클러스터 크기는 많은 커밋을 계산할 때 같은 목적으로 남아 있습니다. 그러므로 종료되지 않은 클러스터 내 5 코어 서버는 이제 종료 전 3/5 마진 커밋보다 타이트한 3/4 멤버 동의를 필요로합니다. 

코어 서버가 실패할 경우, 스크립트 작동 또는 모니터링은 필요할 경우 클러스터에 개입하기 위해서 경고를 띄웁니다. 

만약 리버가 리더 역할을 하는 경우, 새로운 리더를 뽑기 위해서 간단한 선거가 있을 것 입니다. 새로운 리더가 생기면, 코어 클러스터는 중복이 적어도 계속됩니다. 이 실패가 있더라도, 4 개로 축소 된 5 개의 서버 코어 클러스터는 읽기 전용이 되기 전 한 개 이상의 에러를 수용할 수 있습니다. 