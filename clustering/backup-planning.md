
### 4.5. 백업 계획 

```
이 장에서는 Neo4j 인과관계의 클러스터 백업 전략을 설계시 고려사항에 대해 다룹니다.
```

Neo4j 인과관계 클러스터에서 코어 서버 및 읽기 복제본 모두 클러스터를 백업할 때 사용할 수 있습니다. 이 장에서는 사용할 백업 전략을 결정하기 전에 고려해야 할 몇 가지 고려 사항에 대해 설명합니다. 백업 및 복구 명령에 대한 자세한 내용은 [백업 챕터](/backup.md)에서 확인할 수 있습니다. 

#### 4.5.1. 읽기 복제본 백업

일반적으로 전형적인 클러스터를 배포할 때, 그 수가 코어 서버보다 훨씬 많기 때문에 읽기 복제본이 백업 공급자 역할을 하도록 선택합니다.

그러나 읽기 복제본은 코어 서버에서 비동기적으로 복제되어 코어 클러스터와 관련된 트랜잭션을 적용할 때 뒤처질 수도 있습니다. 코어 서버에서 읽기 복제본 연결이 끊어지는 경우, 복제본은 오래된 내용일 수도 있습니다. 더 안 좋은 경우는 이전 백업보다 최신이 아닌 것을 백업하는 것 입니다.

다행히 모든 서버에서 마지막으로 처리된 트랜잭션 ID를 확인할 수 있기에 코어 서버가 처리한 최신 트랜잭션 ID과 얼마나 근접한지 확인할 수 있습니다. 올바른 볼 파크에있는 경우 핵심 서버와 관련해서 읽기 복제본에서 백업까지 안전하게 진행할 수 있습니다.
  
Neo4j 트랜잭션 ID는 절대적으로 증가하는 정수 값입니다. 따라서 더 높은 트랜잭션 ID는 더 낮은 트랜잭션 ID보다 더 최신입니다.

Neo4j 서버는 JMX와 Neo4j 브라우저에서 처리된 마지막 트랜잭션 ID를 노출합니다. 최신 트랜잭션 ID는 [Neo4j 메트릭스를 노출](/monitoring/metrics/reference.md) 또는 Neo4j 브라우저에서 확인할 수 있습니다. Neo4j 브라우저에서 처리 된 최신 트랜잭션 ID (및 기타 메트릭스)를 보려면 프롬프트에서 ```:sysinfo```를 입력하십시오.


#### 4.2.5.2. 코어 서버 백업

코어-전용 클러스터에서는 표준작업량을 확장하기 위해 수많은 읽기 복제본을 사용할 수 없습니다. 따라서 우리는 물리적 근접성, 대역폭, 성능, 활성 상태 등과 같은 요소를 고려하여 서버를 선택합니다.

일반적으로 클러스터는 대규모 백업이 수행되는 동안 정상적으로 작동합니다. 그러나 백업 중에 서버에 IO 부담이 추가적으로 가해져서 성능에 영향을 미칠 수도 있습니다.

보수적인 관점에서는 성능이 클러스터의 다른 인스턴스보다 안 좋다고 가정하고 백업 서버는 사용할 수 없는 인스턴스로 취급합니다. 이 경우, 하나의 더 느린 서버가 장애를 가리기 위해 용량을 줄이지 않도록 클러스터에 충분한 중복성이 있는 것이 좋습니다.

우리는 이 보수 전략을 클러스터 계획에 반영할 수 있습니다. 방정식 ```M = 2F + 1```은 ```F``` 결함을 허용할 때 필요한 클러스터 구성원 수인 ```M```과의 관계를 입증합니다. 백업 중 클러스터에서 하나의 느린 시스템 속도륵 견디도록 ```F```를 증가시킵니다. 따라서 원래 3대의 핵심 서버 클러스터가 하나의 장애를 허용할 것으로 예상했다면, 안전한 중복성 중복 수준을 유지하기 위해 5개로 늘릴 수 있습니다.
