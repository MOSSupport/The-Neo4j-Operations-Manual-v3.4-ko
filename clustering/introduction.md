
## 4.1. 소개

```
이 섹션에서는 Neo4j 인과 클러스터링에 대해 소개합니다.
```

Neo4j 인과관계 클러스터링은 다음 세 가지 기능을 제공합니다. 

1. 안전성: 코어 서버는 트랜잭션 처리를 위해 내결함성 플랫폼을 제공하며, 코어 서버의 많은 부분이 작동하는 동안 계속 사용할 수 있습니다.

2. 규모: 읽기 복사본은 그래프 작업량이 많은 배포 토플러지에서 실행되도록 그래프 쿼리에서 큰 플랫폼을 제공합니다. 

3. 인과 관계의 일관성: 호출될 때, 자신의 쓰기를 읽도록 클라이언트 응용 프로그램은 보장됩니다. 

이를 통해 엔드-유저의 시스템이 여러 기능을 수행하며, 하드웨어 및 네트워크 오류 발생 시 데이터베이스에 대한 읽기 및 쓰기가 가능하고 데이터베이스 상호 작용 추론이 쉽습니다. 

이 섹션의 나머지 부분에는 인과 관계 클러스터링이 프로덕션 및 운용과 어플리케이션에서 어떻게 작용하는지에 대한 개요를 보여줍니다. 
 
### 4.1.1. 운용적 관점

운용 관점에서 볼 때, 클러스터는 두 가지 역할로 구성되었다고 보는 것이 좋습니다: 코어 및 읽기 복제본. 


**그림 4.1. 인과 관계 클러스터 아키텍처**

![인과관계 클러스터링](https://neo4j.com/docs/operations-manual/3.4/images/causal-clustering.svg)


두 역할은 모든 프로덕션 배포에서 기본이지만 서로 다른 방법으로 관리하며 전체 클러스터의 내결함성과 확장성을 관리할 때도 서로 다른 역할을 수행합니다.

#### 4.1.1.1. 코어 서버 

코어 서버의 주요 책임은 데이터를 보호하는 것 입니다. 코어 서버는 Raft 프로토콜을 사용하여 모든 트랜잭션을 모사함으로써 이 작업을 수행합니다. Raft는 엔드 유저 어플리케이션에 대한 트랜잭션 커잇을 확인하기 전에 데이터가 안전하게 유지될 수 있도록 합니다. 실제로 이것은 클러스터 (```N/2+1```) 내 많은 코어 서버가 트랜잭션을 확인했으며, 이것은 엔드 유저 어플리케이션에 대한 커밋을 확인하는 것이 안전하다는 것을 의미합니다. 
 
안정성 요구사항은 쓰기 지연에 영향을 미칩니다. 암시적으로 쓰기는 가장 빠른 응답자에 의해 인정되지만, 클러스터의 코어 서버 수가 증가함에 따라 쓰기를 확인에 필요한 대부분의 사이즈가 증가합니다.

실제로 이는 일반적인 코어 서버 클러스터에 비교적 적은 수의 컴퓨터가있어 특정 배포에 대해 충분한 내결함성을 제공 할 수 있음을 의미합니다. 이것은 ```F```가 오류를 포함하는데 필요하고 ```M```이 코어 서버의 개수를 뜻하는 ```M = 2F +1``` 공식으로 계산합니다. 예를 들어, 실패한 코어 서버 2 개를 허용하려면 클러스터 5 개를 배포해야합니다.

코어 서버 클러스터가 처리 할 수 없는 쓰기 오류가 발생하면, 읽기 전용이 되어 안전성을 유지합니다.

#### 4.1.1.2. 읽기 복사본 

읽기 본사본의 주요 책임은 그래프 작업 (Cypher 쿼리, 절차 등등)을 확장하는 것 입니다. 읽기 복제본은 핵심 서버가 보호하는 데이터 캐시처럼 작동하지만 단순한 키 - 값 캐시가 아닙니다. 실제로 읽기 복제본은 임의의 (읽기 전용) 그래프 쿼리 및 프로시저를 실행하는 완전한 Neo4j 데이터베이스 입니다.

읽기 복사본은 코어 서버에서 트랜잭션 로그로 비동기적으로 모사됩니다. 주기적으로 (주로 ms 범위내에서) 모든 새로운 트랜잭션의 읽기 복제본은 코어 서버를 폴링하고 코어 서버는 이 트랜잭션을 읽기 복제본으로 옮길 것 입니다. 많은 읽기 복제본은 상대적으로 적은 양의 코어 서버에서 데이터를 받으므로 규모별로 쿼리 작업량에 펼쳐진 것을 확인할 수 있습니다.  

그러나 코어 서버와는 다르게 읽기 복제본은 클러스터 토플러지 의사 결정에 관여하지 않습니다. 보통 읽기 복제본은 상대적으로 많이 실행되며 일회용으로 취급합니다. 읽기 복제본 손실은 그래프 쿼리 처리량 마찰 손실 외에 클러스터 이용에 영향을 주지 않습니다. 이것은 클러스터 결함 허용 역량에 영향을 주지 않습니다.  


### 4.1.2. 인과관계의 일관성 

클러스터의 운영 방법은 어플리케이션 관점에서 보면 흥미롭지만 어플리케이션이 그들의 작업을 끝내기 위해서 데이터베이스를 사용하는 방법을 보면 도움이 됩니다. 어플리케이션에서는 그래프에서 읽고 그래프에 쓰는 것이 일반적 입니다. 작업의 성격에 따라 인과관계 일관성을 보장하고 이전 쓰기를 고려하여 그래프에서 읽는 것이 좋습니다. 

인과관계 일관성은 분산 컴퓨터에서 사용하는 거대한 일관성 모델 중 하나입니다. 이것은 인과 관계가있는 작업이 시스템의 모든 인스턴스에서 동일한 순서로 표시되도록 합니다. 클라이언트 어플리케이션은 오래된 데이터를 참고하지 않으며, 그것이 단일 서버인 것처럼 데이터베이스와 (논리적으로) 상호작용합니다. 그 결과, 클라이언트 어플리케이션은 자신의 읽기, 쓰기 의미론으로 대규모 클러스터와 상호작용을 간단하고 예측 가능하게 합니다. 


인과관계 일관성은 코어 서버(데이터가 안전한 곳)에 읽고 쓰기가 용이하게 만들며, 읽기 복제본(그래프 작동이 스케일 아웃되는 곳)에 쓰인 것을 읽어옵니다. 예를 들어, 인과관계 일관성은 같은 사용자가 연속적으로 로그인을 시도할 때 존재하는 사용자 계정 정보에 쓰기가 제공되는 것을 보장합니다. 

**그림 4.2. Neo4j 드라이버를 통하여 인과관계 일관성으로 인과관계 클러스터 설정**

![causal clustering drivers](https://neo4j.com/docs/operations-manual/3.4/images/causal-clustering-drivers.svg)


트랜잭션을 실행할 때, 클라이언트는 연속 트랜잭션 변수로 존재하는 북마크를 요청할 수 있습니다. 북마크를 사용해서 클러스터는 클라이언트가 북마크한 트랜잭션은 처리한 서버만 다음 트랜잭션에서 실행하도록 설정할 수 있습니다. 이것은 클라이언트 관점에서 올바른 읽기-후-쓰기를 보장하는 인과관계 체인을 제공합니다. 

북마크 외에 모든 것은 클러스터에 의해 처리됩니다. 데이터베이스 드라이버는 높은 수준의 서비스를 제공하기 위해 가장 적절한 코어 서버 및 읽기 복제본을 선택하는 클러스터 토플러지 메니저와 작동합니다. 

### 4.1.3. 요약

이 섹션에서는 운영 및 어플리케이션 배포 관점에서 높은 수준의 인과관계 클러스터링을 검사했습니다. 이제 우리는 더 많은 읽기 복제본이 그래프 쿼리 작업량 처리를 책임지는 동안 클러스터 내 코어 서버는 데이터의 장기간 안전유지를 책임집니다. 이 강력한 아키텍처에 대한 추론은 인과 관계 일관성과 같은 읽기 레벨을 제공하고 클러스터 토폴로지를 추상화하는 Neo4j 드라이버에 의해 크게 단순화됩니다.
