
### 4.8.1. 도입 
 
```
이 섹션에서는 공유 검색 서비스가 있는 여러 인과관계-클러스터 Neo4j 멀티 클러스터링 실행에 대해 소개합니다.
```


데이터베이스 문맥 중 [멀티테넌시](https://en.wikipedia.org/wiki/Multitenancy)는 단일 데이터베이스 관리 시스템이 별개의 다중 데이터베이스를 관리하는 내용을 포함합니다. 이 데이터베이스는 별개의 다수 클라이언트가 조회하여 쿼리 할 수 ​​있습니다.

Neo4j를 이용해 자체 데이터베이스를 관리하는 다중 Neo4j 인과관계 클러스터를 공유 검색 서비스가 있는 다중 클러스터로 구성하여 이 작업을 수행합니다. 다중-클러스터의 각 멤버는 데이터베이스 이름으로 구성됩니다. 동일한 데이터베이스를 관리하는 구성원은 다중 클러스터의 단일 검색 서비스로 그룹화되어 여러 개의 작은 클러스터 [Raft 합의 그룹](././lifecycle.md)을 구성합니다. — 이것은 개별 클러스터 입니다. 

이것은 검색 서비스가 클러스터 내 모든 코어 인스턴스를 사용하고 Raft 합의 그룹을 형성하는 Neo4j 인과관계 클러스터링 기본 동작과는 다릅니다. 실제로, 기본 클러스터링은 모든 인스턴스가 기본적으로 동일한 데이터베이스 이름을 가진 다중-클러스터링의 특별한 케이스입니다. 

한번 생성되면, 각 클러스터 성분은 대부분 완전히 구별됩니다. 이들은 개별로 쿼리되며, 결과적으론 다른 저장소 내용을 포함할 것 입니다. 뿐만아니라 한 클러스터의 내결함성은 다른 클러스터의 내결함성에 종속되지 않습니다.
 
예를 들어, Neo4j 인과관계 클러스터가 15개 인스턴스를 포함한다고 생각하면 9개는 코어 인스턴스며, 6개는 읽기복제본 입니다. 세 가지 코어 및 두 가지 읽기 복제본 그룹은 데이터베이스 이름 각각 ```foo```, ```bar``` 및  ```baz```로 설정됩니다. 아래 그림은 이 배포를 반영합니다. 

**그림 4.18. 세 가지 별개 클러스터가 있는 다중-클러스터**

![multicluster high level example](https://neo4j.com/docs/operations-manual/3.4/images/multicluster-high-level-example.svg)

이 시나리오에서 모든 ```foo``` 인스턴스는 쿼리에 응답하는 ```bar``` 인스턴스의 기능에 영향을 주지 않으면서 오프라인할 수 있습니다. 마찬가지로, 한 클러스터 선출은 다른 것의 선출을 유발하지 않습니다. 

세 가지 독립 클러스터 실행의 차이점은 모든 다중-클러스터 멤버가 검색 서비스를 공유한다는 점 입니다. 
모든 단일 클러스터 멤버는 다른 클러스터 멤버의 이름과 그들이 다루는 데이터베이스 이름까지 알고 있습니다. 이렇게하면 멀티 클러스터 라우팅 멤버에게 데이터베이스를 이름 별로 라우팅 정보를 요청할 수 있습니다. 그러므로 클라이언트 커넥터 아이브러리는, Neo4j 드라이버와 같이 데이터베이스가 복제되고 이름으로 쓰여진 통일된 디렉토리 서비스를 제공합니다. 

#### 4.8.1.1. 알려진 제한사항 

- 다중-클러스터 내에 각 클러스터는 오직 한 개의 별개 데이터베이스를 가집니다. 예를 들어, 다중-클러스터를 두 가지 별개 데이터베이스를 갖도록 구성하려면 적어도 4가지 코어 인스턴스를 제공해야 합니다. (즉,  ```causal_clustering.minimum_core_cluster_size_at_formation```는 각 클러스터 별로 최소 ```2```개를 가져야 합니다.)

- 단일 트랜잭션은 다중 구성 클러스터를 읽거나 갱신 할 수 없습니다.

- 클러스터 구성 성부 사이 어던 데이터도 자동으로 공유되거나 복제할 수 없습니다. 

- 클러스터의 인스턴스를 중지하고 바인드 해제 한 후 나머지 멀티 클러스터가 계속 실행중인 경우 최근에 바운드 클러스터가 멀티 클러스터에 재결합되도록 모든 클러스터의 멤버를 재시작할 수도 있습니다.

 